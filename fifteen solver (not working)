//
//  FifteenGame.h
//  Fifteen solver
//
//  Created by Александр Малышев on 17.05.15.
//  Copyright (c) 2015 SecurityQQ. All rights reserved.
//

#ifndef Fifteen_solver_FifteenGame_h
#define Fifteen_solver_FifteenGame_h

#include <vector>
#include <cmath>

#define MOVE_FAIL (-1)
#define MOVE_OK 0
#define FOUND (-1024)
#define NOT_FOUND (-512)
#define INF UINT32_MAX

typedef unsigned int uint;

enum Motion {
    keyUp    = 'U',
    keyLeft  = 'L',
    keyDown  = 'D',
    keyRight = 'R'
};

Motion reverseMotion(const Motion motion) {
    switch (motion) {
        case 'U':
            return keyDown;
            break;
        case 'L':
            return keyRight;
            break;
        case 'D':
            return keyUp;
            break;
        case 'R':
            return keyLeft;
            break;
    }
}

class FifteenGame {
public:
    
    FifteenGame();
    FifteenGame(short boardSize);
    ~FifteenGame();
    
    FifteenGame defaultBoard();
    FifteenGame newGame();
    void printBoard();

    int move(const Motion motion);
    void moveWithArrayOfMotions(const std::vector<Motion> motions);
    unsigned int getEuristic();
    
    friend bool operator== (const FifteenGame &g1, const FifteenGame &g2);
    friend bool operator!= (const FifteenGame &g1, const FifteenGame &g2);
    
    
    std::vector<Motion> getSuccessorsDir();
    uint search(FifteenGame node, uint curCost, uint bound, std::vector<Motion> path, std::vector<FifteenGame> &checkedStates);
    uint solve();
private:
    
    
    const short DefaultBoardSize = 4;
    std::pair<short, short> nullPosition;
    std::vector<std::vector<uint>> board;
    
};


FifteenGame:: FifteenGame() {
    board.assign(DefaultBoardSize, std::vector<uint>(DefaultBoardSize, 0));
}

FifteenGame:: FifteenGame(short boardSize) {
    board.assign(boardSize, std::vector<uint>(boardSize, 0));
}

FifteenGame:: ~FifteenGame() {
    
}

FifteenGame FifteenGame:: defaultBoard() {
    FifteenGame defaultGame(board.size());
    for (short i = 1; i < board.size() * board.size(); ++i) {
        defaultGame.board[(i - 1) / board.size()][(i - 1) % board.size()] = i;
    }
    defaultGame.nullPosition = std::make_pair(board.size() - 1, board.size() - 1);
    return defaultGame;
}

void FifteenGame:: printBoard() {
    short maxDigit = (short)log10(board.size() * board.size()) + 1;
    for (auto i = board.begin(); i != board.end(); ++i) {
        for (auto j = i->begin(); j != i->end(); ++j) {
            if (*j == 0) {
                std::cout<<"_";
            } else {
                std::cout<<*j;
            }
            for (int i = 0; i < (maxDigit - (short)log10(*j)); ++i) {
                std::cout<<" ";
            }
        }
        std::cout<<std::endl;
    }
}

int FifteenGame:: move(const Motion motion) {
    switch (motion) {
        case 'U':
            if (nullPosition.first == 0) {
                return MOVE_FAIL;
            }
            std::swap(board[nullPosition.first][nullPosition.second], board[nullPosition.first - 1][nullPosition.second]);
            nullPosition.first--;
            break;
        case 'L':
            if (nullPosition.second == 0) {
                return MOVE_FAIL;
            }
            std::swap(board[nullPosition.first][nullPosition.second], board[nullPosition.first][nullPosition.second - 1]);
            nullPosition.second--;
            break;
        case 'D':
            if (nullPosition.first == (board.size() - 1)) {
                return MOVE_FAIL;
            }
            std::swap(board[nullPosition.first][nullPosition.second], board[nullPosition.first + 1][nullPosition.second]);
            nullPosition.first++;
            break;
        case 'R':
            if (nullPosition.second == (board.size() - 1)) {
                return MOVE_FAIL;
            }
            std::swap(board[nullPosition.first][nullPosition.second], board[nullPosition.first][nullPosition.second + 1]);
            nullPosition.second++;
            break;
            
        default:
            //TODO: exeption
            break;
    }
    return MOVE_OK;
}

void FifteenGame:: moveWithArrayOfMotions(const std::vector<Motion> motions) {
    for (auto i = motions.begin(); i != motions.end(); ++i) {
        move(*i);
    }
}

FifteenGame FifteenGame:: newGame() {
    
    FifteenGame newGame = defaultBoard();
    srand(time(NULL));
    for (int i = 0; i < 50 * board.size() * board.size(); ++i) {
        switch (rand() % 4) {
            case 0:
                newGame.move(keyUp);
                break;
            case 1:
                newGame.move(keyLeft);
                break;
            case 2:
                newGame.move(keyDown);
                break;
            case 3:
                newGame.move(keyRight);
                break;
        }
    }
    return newGame;
}

unsigned int FifteenGame:: getEuristic() {
    unsigned int euristic = 0;
    for (short i = 0; i < board.size(); ++i) {
        for (short j = 0; j < board.size(); ++j) {
            if (board[i][j] == 0) {
                euristic += abs(i - (short)board.size() + 1) + abs(j - (short)board.size() + 1);
            } else {
                euristic += abs(((short)i - (short)(board[i][j] - 1) / (short)board.size()) + abs(j - (short)(board[i][j] - 1) % (short)board.size()));
            }
        }
    }
    
    return euristic / 2;
}



bool operator== (const FifteenGame &g1, const FifteenGame &g2) {
    if (g1.board.size() != g2.board.size()) { return false; }
    if (g1.nullPosition != g2.nullPosition) { return false; }
    for (short i = 0; i < g1.board.size(); ++i) {
        for (short j = 0; j < g1.board.size(); ++j) {
            if (g1.board[i][j] != g2.board[i][j]) {
                return false;
            }
        }
    }
    return true;
}
bool operator!= (const FifteenGame &g1, const FifteenGame &g2) {
    return !operator==(g1, g2);
}

std::vector<Motion> FifteenGame:: getSuccessorsDir() {
    std::vector<Motion> successors;
    FifteenGame aSuccessor = *this;
    aSuccessor.move(keyLeft);
    if (aSuccessor != *this) {
        successors.push_back(keyLeft);
        aSuccessor.move(keyRight);
    }
    aSuccessor.move(keyRight);
    if (aSuccessor != *this) {
        successors.push_back(keyRight);
        aSuccessor.move(keyLeft);
    }
    aSuccessor.move(keyUp);
    if (aSuccessor != *this) {
        successors.push_back(keyUp);
        aSuccessor.move(keyDown);
    }
    aSuccessor.move(keyDown);
    if (aSuccessor != *this) {
        successors.push_back(keyDown);
        aSuccessor.move(keyUp);
    }
    return successors;
}

int a = 0;

uint FifteenGame:: search(FifteenGame node, uint curCost, uint bound, std::vector<Motion> path, std::vector<FifteenGame> &checkedStates) {
    ++a;
    uint minCost = curCost + node.getEuristic();
    
    if (a % 5000 == 0) {
        std::cout<<"-new search(" <<a <<")-\n";
        std::cout<<"Current cost: " <<curCost <<" Current bound: "<<bound<<" MinCost:"<< minCost<<std::endl;
        for (auto i = path.begin(); i != path.end(); ++i) { std::cout<<char(*i); } std::cout<<std::endl;
        node.printBoard();
    }
    
    if (minCost == curCost) {
        for (auto i = path.begin(); i != path.end(); ++i) { std::cout<<char(*i); }
        return FOUND;
    }

    if (minCost > bound) {
        return minCost;
    }
    uint min = INF;
    //TODO: successors shouldn't be checked twice!
    //TODO: STILL DON'T
    auto next = node.getSuccessorsDir();
    
    
    for (auto i = next.begin(); i != next.end(); ++i) {
        FifteenGame newNode = node;
//        FifteenGame prevNode = node;
        newNode.move(*i);
        
//        if (path.size() > 0) {
//            prevNode.move(reverseMotion(path[path.size() - 1]));
//            if (newNode == prevNode) {
//                continue;
//            }
//        }
        
        bool goNext = false;
        for (auto i = checkedStates.begin(); i != checkedStates.end(); ++i) {
            if (*i == newNode) {
                goNext = true;
            }
        }
        
        
//        std::cout<<"--prev & next:--\n";
//        prevNode.printBoard();
//        newNode.printBoard();
//        std::cout<<"-----\n-----\n";
//
        if (!goNext) {
            path.push_back(*i);
            checkedStates.push_back(newNode);
            uint t = search(newNode, curCost + 1, bound, path, checkedStates);
            
            if (t == FOUND) {
                return FOUND;
            }
            if (t < min) {
                min = t;
            }
            path.pop_back();
        }
    }
    
    return min;
}

uint FifteenGame:: solve() {
    uint bound = getEuristic();
    std::vector<Motion> path;
    while (true) {
        std::vector<FifteenGame> checkedStates;
        uint t = search(*this, 0, bound, path, checkedStates);
        
        if (t == FOUND) {
            return FOUND;
        }
        if (t == INF) {
            return NOT_FOUND;
        }
        bound = t;
    }
}

#endif
